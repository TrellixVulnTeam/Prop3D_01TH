{% extends "base.html" %}

{% block head %}
<style type="text/css">
.svg-container {
    display: inline-block;
    position: relative;
    width: 100%;
    padding-bottom: 100%; /* aspect ratio */
    vertical-align: top;
    overflow: hidden;
}
.svg-content-responsive {
    display: inline-block;
    position: absolute;
    top: 10px;
    left: 0;
}
</style>
{% endblock %}

{% block content %}
<div class="contianer">
  <div class="row">
      <div class="col-xs-3">
        <h4>Voxel Size: <span id="voxel_size">0.5</span>&#x212b;</h4>
        <div id="voxel_slider"></div>

        <h4>Volume: <span id="volume">256</span>&#x212b;</h4>
        <div id="volume_slider"></div>

        <h4>Expand Atom:</h4>
        <input type="checkbox" checked data-toggle="switch" data-on-color="default" data-off-color="primary" id="expand_atom" /></h4>
      </div>
      <div class="col-xs-6">
        <div id="voxel_browser" class="width:800px;height:800px;vertical-align:top;"></div>
        <!--<svg id="voxel_browser" width="316" height="500" viewbox="0 0 316 500" style"display: block; margin: auto; text-align:center;" preserveAspectRatio="xMidYMin"></svg>-->
      </div>
      <div class="col-xs-3">
        <h3>{{request.args.get('pdb')}}.{{request.args.get('chain')}}</h3>
        <h4>Voxel: <span id="curr_voxel">0, 0, 0</span></h4>
        <h4>Atom: <span id="curr_atom_serial">0</span> @ <span id="curr_atom_xyz">0, 0, 0</span></h4>
        <table id="feature_table" data-toggle="table">
            <tr>
                <th data-field="name">Field</th>
                <th data-field="value">Value</th>
            </tr>
        </table>
      </div>
  </div>
</div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="{{ url_for('static', filename='js/three.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/TrackballControls.js') }}"></script>
<script type="text/javascript">
var origin = [0, 0], scale = 2, cubesData = [], xGrid_data = [], yLine=[], alpha = 0, beta = 0, startAngle = Math.PI/6, objects = [], isMouseDown=false;
var svg, cubes3D, grid3d, cubesGroup, color_type, mx, my, mouseX, mouseY, voxel_slider, voxel_size_value, volume_value, scene, camera, renderer, voxel_with_color, voxelGeo, raycaster, mouse;

var colors = [
  "#1f77b4",
  "#aec7e8",
  "#ff7f0e",
  "#ffbb78",
  "#2ca02c",
  "#98df8a",
  "#d62728",
  "#ff9896",
  "#9467bd",
  "#c5b0d5",
  "#8c564b",
  "#c49c94",
  "#e377c2",
  "#f7b6d2",
  "#7f7f7f",
  "#c7c7c7",
  "#bcbd22",
  "#dbdb8d",
  "#17becf",
  "#9edae5"
]

$(function() {

    var $voxslider = $("#voxel_slider");
    if ($voxslider.length > 0) {
      $voxslider.slider({
        min: 0.25,
        max: 2.5,
        step: 0.05,
        value: 0.5,
        orientation: "horizontal",
        range: "min"
      }).on("change", changeVoxelSize)
    }
    voxel_size_value = 0.5;

    var $volslider = $("#volume_slider");
    if ($volslider.length > 0) {
      $volslider.slider({
        min: 32.0,
        max: 512.0,
        step: 32.0,
        value: 256.0,
        orientation: "horizontal",
        range: "min"
      })
      //.addSliderSegments($volslider.slider("option").max);
    }
    volume_value = 256.0;

    //$('#expand_atom').bootstrapSwitch({onSwitchChange:change_expand_atom});

    camera = new THREE.PerspectiveCamera( 75, 1, 0.1, 1000 );
    camera.position.set(256,256,256 );
    camera.lookAt( new THREE.Vector3() );

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0xf0f0f0 );
    voxelGeo = new THREE.BoxGeometry(1,1,1);
    voxel_with_color = [];
    $.each(colors, function(i, color){
      voxel_with_color.push(new THREE.MeshBasicMaterial({color:color}));
    })

    raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();
		var geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
		geometry.rotateX( - Math.PI / 2 );
		plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
		scene.add( plane );
		objects.push( plane );

    // var gridHelper = new THREE.GridHelper(512,256);
    // scene.add( gridHelper );
    var geometry = new THREE.Geometry();
    geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 0, 0, 0 ) ) );
    geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 256, 0, 0 ) ) );

    linesMaterial = new THREE.LineColorMaterial( 0x000000, 0.2 );

    for ( var i = 0; i < 128; i ++ ) {

      var line = new THREE.Line( geometry, linesMaterial );
      line.position.z = ( i * 2 ) - 256;
      scene.addObject( line );

      var line = new THREE.Line( geometry, linesMaterial );
      line.position.x = ( i * 2 ) - 256;
      line.rotation.y = 90 * Math.PI / 180;
      scene.addObject( line );

    }

    // Lights
  	var ambientLight = new THREE.AmbientLight( 0x606060 );
  	scene.add( ambientLight );

  	var directionalLight = new THREE.DirectionalLight( 0xffffff );
  	directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
  	scene.add( directionalLight );

  	renderer = new THREE.WebGLRenderer( { antialias: true } );
  	renderer.setPixelRatio( window.devicePixelRatio );
  	renderer.setSize(800,800);// $("#voxel_browser").innerWidth, $("#voxel_browser").innerHeight );
  	$("#voxel_browser").append( renderer.domElement );

    // var controls = new THREE.TrackballControls( camera );
    // controls.rotateSpeed = 3.6;
    // controls.zoomSpeed = 0.8;
    // controls.panSpeed = 1;

    // controls.noZoom = false;
    // controls.noPan = false;

    // controls.staticMoving = false;
    // controls.dynamicDampingFactor = 0.12;

    // controls.enabled = true;

    // controls.addEventListener( 'change', render );

    document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
    document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

    draw_voxels()

    $('#feature_table').bootstrapTable({
      height:750,
      url: "{{url_for('get_atom_features')}}",
      columns:[
        {field:"name", sortable:true},
        {field:"value", sortable:true}]
    });
});

/*
RasMol colors:
ASP, GLU  bright red  [230,10,10] E60A0A
CYS, MET  yellow  [230,230,0] E6E600
LYS, ARG  blue  [20,90,255] 145AFF
SER, THR  orange  [250,150,0] FA9600
PHE, TYR  mid blue  [50,50,170] 3232AA
ASN, GLN  cyan  [0,220,220] 00DCDC
GLY light grey  [235,235,235] EBEBEB
LEU, VAL, ILE green [15,130,15] 0F820F
ALA dark grey [200,200,200] C8C8C8
TRP pink  [180,90,180]  B45AB4
HIS pale blue [130,130,210] 8282D2
PRO flesh [220,150,130] DC9682
*/

function onDocumentMouseDown( event ) {

        event.preventDefault();

        isMouseDown = true;
        mouse.x = event.clientX;
        mouse.y = event.clientY;
}

// function onDocumentMouseDown( event ) {
//     event.preventDefault();
//     mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
//     mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
//     raycaster.setFromCamera( mouse, camera );
//     var intersects = raycaster.intersectObjects( objects );
//     if ( intersects.length > 0 ) {
//         //intersects[ 0 ].object.material.color.set('red');
//         //intersects[ 0 ].object.geometry.scale(1.1,1.1,1.1);
//         if (selected === 0) {
//             selected = 1;
//             selectedObject = intersects[ 0 ].object;
//             selectedObject.material.color.set('red');
//             console.log(selectedObject.position.x);
//         } else {
//             selected = 0;
//             var geometry = new THREE.Geometry();
//             geometry.vertices.push(intersects[ 0 ].object.position);
//             geometry.vertices.push(selectedObject.position);
//             var line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x0000ff }));
//             scene.add(line);

//             selectedObject.material.color.set('black');
//         }

//     }
// }

function onDocumentMouseMove( event ) {

    event.preventDefault();

    if ( isMouseDown ) {

        theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 )
                + onMouseDownTheta;
        phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 )
              + onMouseDownPhi;

        phi = Math.min( 180, Math.max( 0, phi ) );

        camera.position.x = radious * Math.sin( theta * Math.PI / 360 )
                            * Math.cos( phi * Math.PI / 360 );
        camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
        camera.position.z = radious * Math.cos( theta * Math.PI / 360 )
                            * Math.cos( phi * Math.PI / 360 );
        camera.updateMatrix();

    }

    mouse3D = projector.unprojectVector(
        new THREE.Vector3(
            ( event.clientX / renderer.domElement.width ) * 2 - 1,
            - ( event.clientY / renderer.domElement.height ) * 2 + 1,
            0.5
        ),
        camera
    );
    ray.direction = mouse3D.subSelf( camera.position ).normalize();

    interact();
    render();

}

function onWindowResize() {        
    camera.left = window.innerWidth / - 2;
    camera.right = window.innerWidth / 2;
    camera.top = window.innerHeight / 2;
    camera.bottom = window.innerHeight / - 2;
    camera.aspect = window.innerWidth / window.innerHeight;        

    renderer.setSize( window.innerWidth, window.innerHeight );
}

function onDocumentMouseWheel( event ) {
    console.log("scroll");
    var fovMAX = 160;
    var fovMIN = 1;

    camera.fov -= event.wheelDeltaY * 0.05;
    camera.fov = Math.max( Math.min( camera.fov, fovMAX ), fovMIN );
    camera.updateProjectionMatrix(); //projectionMatrix = new THREE.Matrix4().makePerspective(camera.fov, 1.0, camera.near, camera.far);
    render();
}

function draw_voxels(){
  var json_file = get_protein_url();
  d3.json(json_file, function(data) {
    $.each(data["indices"], function(i, coord){
      var voxel = new THREE.Mesh( voxelGeo, voxel_with_color[data["colors"][i]] );
			voxel.position.copy(new THREE.Vector3(coord[0], coord[1], coord[2]));
			//voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
			scene.add( voxel );
			objects.push( voxel );
    });

    render();
    console.log("done drawing voxels");
  });
}

function render() {
  renderer.render( scene, camera );
}

function clickCube(cube){
    console.log(cube);console.log(cube.faces[0]);
    coord = cube.faces[0]
    $("#curr_voxel").text(coord[0].x+", "+coord[0].y+", "+coord[0].z)
    d3.json("{{url_for('get_atoms_in_voxel')}}?i="+coord[0].x+"&j="+coord[0].y+"&k="+coord[0].z, function(data) {
        var atom_serial = data[0][0];
        $("#curr_atom_serial").text(atom_serial);
        $("#curr_atom_xyz").text(data[0][1]);
        if (data.length > 1){
            console.log("switch between atoms somehow");
        }

        $('#feature_table').bootstrapTable('refresh', {url: "{{url_for('get_atom_features')}}?atom_serial="+atom_serial});
    });
}

function changeVoxelSize(){
    voxel_size_value = $("#voxel_slider").getValue();
    if(voxel_size_value==0){
      voxel_size_value = 0.1
    }
    $("#voxel_size").text(voxel_size_value);
    draw_voxels();
}

function changeVolume(){
    volume_value = $("#volume_slider").getValue();
    $("#volume").text(volume_value);
    draw_voxels();
}

function get_protein_url(){
    return "{{url_for('get_protein')}}?pdb={{request.args.get('pdb')}}&chain={{request.args.get('chain')}}&voxel_size="+voxel_size_value+"&voxel_size="+volume_value+"&expand_features="+$('#expand_atom').bootstrapSwitch('state');
}

</script>
{% endblock %}
