{% extends "base.html" %}

{% block head %}
<style type="text/css">
.svg-container {
    display: inline-block;
    position: relative;
    width: 100%;
    padding-bottom: 100%; /* aspect ratio */
    vertical-align: top;
    overflow: hidden;
}
.svg-content-responsive {
    display: inline-block;
    position: absolute;
    top: 10px;
    left: 0;
}
</style>
{% endblock %}

{% block content %}
<div class="contianer">
  <div class="row">
      <div class="col-xs-3">
        <h4>Voxel Size: <span id="voxel_size">0.5</span>&#x212b;</h4>
        <div id="voxel_slider"></div>

        <h4>Volume: <span id="volume">256</span>&#x212b;</h4>
        <div id="volume_slider"></div>

        <h4>Expand Atom:</h4>
        <input type="checkbox" checked data-toggle="switch" data-on-color="default" data-off-color="primary" id="expand_atom" /></h4>
      </div>
      <div class="col-xs-6">
        <div id="voxel_browser" class="vertical-align:top;"></div>
        <!--<svg id="voxel_browser" width="316" height="500" viewbox="0 0 316 500" style"display: block; margin: auto; text-align:center;" preserveAspectRatio="xMidYMin"></svg>-->
      </div>
      <div class="col-xs-3">
        <h3>{{request.args.get('pdb')}}.{{request.args.get('chain')}}</h3>
        <h4>Voxel: <span id="curr_voxel">0, 0, 0</span></h4>
        <h4>Atom: <span id="curr_atom_serial">0</span> @ <span id="curr_atom_xyz">0, 0, 0</span></h4>
        <table id="feature_table" data-toggle="table">
            <tr>
                <th data-field="name">Field</th>
                <th data-field="value">Value</th>
            </tr>
        </table>
      </div>
  </div>
</div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://unpkg.com/d3-3d@0.0.7/build/d3-3d.min.js"></script>
<script type="text/javascript">
var origin = [0, 0], scale = 2, cubesData = [], xGrid_data = [], yLine=[], alpha = 0, beta = 0, startAngle = Math.PI/6;
var svg, cubes3D, grid3d, cubesGroup, color_type, mx, my, mouseX, mouseY, voxel_slider;

$(function() {

    var $voxslider = $("#voxel_slider");
    if ($voxslider.length > 0) {
      $voxslider.slider({
        min: 0.25,
        max: 2.5,
        step: 0.05,
        value: 0.5,
        orientation: "horizontal",
        range: "min"
      }).on("change", changeVoxelSize)
    }
    var voxel_size_value = 0.5;

    var $volslider = $("#volume_slider");
    if ($volslider.length > 0) {
      $volslider.slider({
        min: 32.0,
        max: 512.0,
        step: 32.0,
        value: 256.0,
        orientation: "horizontal",
        range: "min"
      })
      //.addSliderSegments($volslider.slider("option").max);
    }
    var volume_value = 256.0;

    $('#expand_atom').bootstrapSwitch({onSwitchChange:function(){

    }});

    // for(var z = 0; z < 512; z++){
    //     for(var x = 0; x < 512; x++){
    //         xGrid_data.push([{x:x, y:0, z:z}]);
    //     }
    // }

    var key = function(d){ return d.id; };

    // grid3d = d3._3d()
    //         .shape('GRID', 512)
    //         .origin(origin)
    //         // .x(function(d){ return d.x; })
    //         // .y(function(d){ return d.y; })
    //         // .z(function(d){ return d.z; })
    //         //.rotateY( startAngle)
    //         //.rotateX(-startAngle)
    //         .scale(scale);

    cubes3D = d3._3d()
        .shape('CUBE')
        .x(function(d){ return d.x; })
        .y(function(d){ return d.y; })
        .z(function(d){ return d.z; })
        .rotateY( startAngle)
        .rotateX(-startAngle)
        .origin(origin)
        .scale(scale);

    // var yScale3d = d3._3d()
    //     .shape('LINE_STRIP')
    //     .origin(origin)
    //     //rotateY( startAngle)
    //     //.rotateX(-startAngle)
    //     .scale(scale);

    svg = d3.select("div#voxel_browser")
       .append("div")
       .classed("svg-container", true) //container class to make it responsive
       .append("svg")
       //responsive SVG needs these 2 attributes and no width and height attr
       .attr("preserveAspectRatio", "xMinYMin meet")
       .attr("viewBox", "0 0 600 400")
       //class to make it responsive
       .classed("svg-content-responsive", true)
       //.attr("width", "100%")
       //.attr("height", "100%")
       .call(d3.zoom().on("zoom", function () {
              svg.attr("transform", d3.event.transform)
        }));

    console.log(svg)

   /* ----------- GRID ----------- */

    // var xGrid = svg.selectAll('path.grid').data(xGrid_data, key);
    // xGrid.enter()
    //      .append('path')
    //      .attr('class', 'grid')
    //      .attr('fill-opacity', 0.9)
    //      .classed('_3d', true)
    //      .merge(xGrid)
    //      .attr('stroke', 'black')
    //      .attr('stroke-width', 0.3)
    //      .attr('fill', function(d){ return 'lightgrey'; })
    //      .attr('fill-opacity', 0.9)
    //      .attr('d', grid3d.draw);
    // xGrid.exit().remove();

    /* ----------- y-Scale Text ----------- */

    // d3.range(0, 512, 1).forEach(function(d){ yLine.push([0, -d, 0]); });

    // var yText = svg.selectAll('text.yText').data(yLine[0]);

    // yText
    //     .enter()
    //     .append('text')
    //     .attr('class', '_3d yText')
    //     .attr('dx', '.3em')
    //     .merge(yText)
    //     .each(function(d){
    //         d.centroid = {x: d.rotated.x, y: d.rotated.y, z: d.rotated.z};
    //     })
    //     .attr('x', function(d){ return d.x; })
    //     .attr('y', function(d){ return d.y; })
    //     .text(function(d){ return d[1] <= 0 ? d[1] : ''; });

    // yText.exit().remove();

    cubesGroup = svg.append('g').attr('class', 'cubes')
    svg.call(d3.drag().on('drag', dragged).on('start', dragStart).on('end', dragEnd)).append('g');

    draw_voxels("{{url_for('get_protein')}}?pdb={{request.args.get('pdb')}}&chain={{request.args.get('chain')}}")

    voxel_slider = $('#voxel_slider').slider()
		    .on('slide', changeVoxelSize)
		    .data('slider');

    $('#feature_table').bootstrapTable({
      height:750,
      url: "{{url_for('get_atom_features')}}",
      columns:[
        {field:"name", sortable:true},
        {field:"value", sortable:true}]
    });
});

/*
RasMol colors:
ASP, GLU  bright red  [230,10,10] E60A0A
CYS, MET  yellow  [230,230,0] E6E600
LYS, ARG  blue  [20,90,255] 145AFF
SER, THR  orange  [250,150,0] FA9600
PHE, TYR  mid blue  [50,50,170] 3232AA
ASN, GLN  cyan  [0,220,220] 00DCDC
GLY light grey  [235,235,235] EBEBEB
LEU, VAL, ILE green [15,130,15] 0F820F
ALA dark grey [200,200,200] C8C8C8
TRP pink  [180,90,180]  B45AB4
HIS pale blue [130,130,210] 8282D2
PRO flesh [220,150,130] DC9682
*/

function draw_voxels(){
  var json_file = get_protein_url();
  d3.json(json_file, function(data) {
    cubesData = [];
    color_type = data["color_type"];
    var cnt = 0;
    $.each(data["indices"], function(i, coord){
      var _cube = makeCube(coord[0], coord[1], coord[2])
      _cube.id = 'cube_' + cnt++;
      _cube.color = data["colors"][i];
      cubesData.push(_cube);
    });
    console.log(cubesData);
    processData(cubes3D(cubesData), 1000, data["color_type"]);
    console.log("done drawing voxels");
  });
}

// d3.select('#voxel_browser').append("rect")
//     .attr("width", "100%")
//     .attr("height", "100%")
//     .attr("fill", "pink");


function processData(data, tt, color_type){
    if(color_type=="category"){
      var color = d3.scaleOrdinal(d3.schemeCategory20);
    }
    else{
      var color = d3.scaleLinear().domain([0,1])
        .interpolate(d3.interpolateHcl)
        .range([d3.rgb("#08306b"), d3.rgb('#a50f15')]);
    }

    /* --------- CUBES ---------*/

    var cubes = cubesGroup.selectAll('g.cube').data(data, function(d){ return d.id });

    var ce = cubes
        .enter()
        .append('g')
        .attr('class', 'cube')
        .attr('fill', function(d){ return color(d.color); })
        .attr('stroke', function(d){ return color(d.color); })
        .on("click", clickCube)
        .merge(cubes)
        .sort(cubes3D.sort);

    cubes.exit().remove();

    /* --------- FACES ---------*/

    var faces = cubes.merge(ce).selectAll('path.face').data(function(d){ return d.faces; }, function(d){ return d.face; });

    faces.enter()
        .append('path')
        .attr('class', 'face')
        .attr('fill-opacity', 0.6)
        .classed('_3d', true)
        .merge(faces)
        .transition().duration(tt)
        .attr('d', cubes3D.draw);

    faces.exit().remove();


    /* --------- TEXT ---------*/

    // var texts = cubes.merge(ce).selectAll('text.text').data(function(d){
    //     var _t = d.faces.filter(function(d){
    //         return d.face === 'top';
    //     });
    //     return [{height: d.height, centroid: _t[0].centroid}];
    // });

    // texts
    //     .enter()
    //     .append('text')
    //     .attr('class', 'text')
    //     .attr('dy', '-.7em')
    //     .attr('text-anchor', 'middle')
    //     .attr('font-family', 'sans-serif')
    //     .attr('font-weight', 'bolder')
    //     .attr('x', function(d){ return origin[0] + scale * d.centroid.x })
    //     .attr('y', function(d){ return origin[1] + scale * d.centroid.y })
    //     .classed('_3d', true)
    //     .merge(texts)
    //     .transition().duration(tt)
    //     .attr('fill', 'black')
    //     .attr('stroke', 'none')
    //     .attr('x', function(d){ return origin[0] + scale * d.centroid.x })
    //     .attr('y', function(d){ return origin[1] + scale * d.centroid.y })
    //     .tween('text', function(d){
    //         var that = d3.select(this);
    //         var i = d3.interpolateNumber(+that.text(), Math.abs(d.height));
    //         return function(t){
    //             that.text(i(t).toFixed(1));
    //         };
    //     });

    // texts.exit().remove();

    /* --------- SORT TEXT & FACES ---------*/

    ce.selectAll('._3d').sort(d3._3d().sort);

}

function dragStart(){
    mx = d3.event.x;
    my = d3.event.y;
}

function dragged(){
    mouseX = mouseX || 0;
    mouseY = mouseY || 0;
    beta   = (d3.event.x - mx + mouseX) * Math.PI / 230 ;
    alpha  = (d3.event.y - my + mouseY) * Math.PI / 230  * (-1);
    processData(cubes3D.rotateY(beta + startAngle).rotateX(alpha - startAngle)(cubesData), 0, color_type);
}

function dragEnd(){
    mouseX = d3.event.x - mx + mouseX;
    mouseY = d3.event.y - my + mouseY;
}

function clickCube(cube){
    console.log(cube);console.log(cube.faces[0]);
    coord = cube.faces[0]
    $("#curr_voxel").text(coord[0].x+", "+coord[0].y+", "+coord[0].z)
    d3.json("{{url_for('get_atoms_in_voxel')}}?i="+coord[0].x+"&j="+coord[0].y+"&k="+coord[0].z, function(data) {
        var atom_serial = data[0][0];
        $("#curr_atom_serial").text(atom_serial);
        $("#curr_atom_xyz").text(data[0][1]);
        if (data.length > 1){
            console.log("switch between atoms somehow");
        }

        $('#feature_table').bootstrapTable('refresh', {url: "{{url_for('get_atom_features')}}?atom_serial="+atom_serial});
    });
}

function makeCube(x, y, z){
    return [
        {x: x,   y: y,   z: z},   // FRONT TOP LEFT
        {x: x,   y: y+1, z: z},   // FRONT BOTTOM LEFT
        {x: x+1, y: y+1, z: z},   // FRONT BOTTOM RIGHT
        {x: x+1, y: y,   z: z},   // FRONT TOP RIGHT
        {x: x,   y: y,   z: z+1}, // BACK  TOP LEFT
        {x: x,   y: y+1, z: z+1}, // BACK  BOTTOM LEFT
        {x: x+1, y: y+1, z: z+1}, // BACK  BOTTOM RIGHT
        {x: x+1, y: y,   z: z+1}, // BACK  TOP RIGHT
    ];
}

function changeVoxelSize(){
    voxel_size_value = $("#voxel_slider").getValue();
    if(voxel_size_value==0){
      voxel_size_value = 0.1
    }
    $("#voxel_size").text(voxel_size_value);
    draw_voxels();
}

function changeVolume(){
    volume_value = $("#volume_slider").getValue();
    $("#volume").text(volume_value);
    draw_voxels();
}

function get_protein_url(){
    return "{{url_for('get_protein')}}?pdb={{request.args.get('pdb')}}&chain={{request.args.get('chain')}}&voxel_size="+voxel_size_value+"&voxel_size="+volume_value+"&expand_features="+$('#expand_atom').bootstrapSwitch('state');
}

</script>
{% endblock %}
